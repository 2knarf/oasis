From 16e9c4852eb471f9a96219ab38b6bb44a8d49ac9 Mon Sep 17 00:00:00 2001
From: Michael Forney <mforney@mforney.org>
Date: Wed, 20 Nov 2019 00:01:42 -0800
Subject: [PATCH] copy: Fix use of compound literal outside its scope

C99 6.5.2.5p6:
> If the compound literal occurs outside the body of a function,
> the object has static storage duration; otherwise, it has automatic
> storage duration associated with the enclosing block.

So, we can't use the address of a compound literal here. Instead,
just set p to NULL, and make the loop conditional on p being non-NULL.
---
 copy.c | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/copy.c b/copy.c
index 3aa3b98..6fb0f98 100644
--- a/copy.c
+++ b/copy.c
@@ -77,7 +77,7 @@ phisimpl(Phi *p, Ref r, Ref *cpy, Use ***pstk, BSet *ts, BSet *as, Fn *fn)
 	while (nstk) {
 		u = stk[--nstk];
 		if (u->type == UIns && iscopy(u->u.ins, r, fn)) {
-			p = &(Phi){.narg = 0};
+			p = NULL;
 			t = u->u.ins->to.val;
 		}
 		else if (u->type == UPhi) {
@@ -89,13 +89,15 @@ phisimpl(Phi *p, Ref r, Ref *cpy, Use ***pstk, BSet *ts, BSet *as, Fn *fn)
 		if (bshas(ts, t))
 			continue;
 		bsset(ts, t);
-		for (a=0; a<p->narg; a++) {
-			r1 = copyof(p->arg[a], cpy);
-			if (req(r1, r))
-				continue;
-			if (rtype(r1) != RTmp)
-				return;
-			bsset(as, r1.val);
+		if (p) {
+			for (a=0; a<p->narg; a++) {
+				r1 = copyof(p->arg[a], cpy);
+				if (req(r1, r))
+					continue;
+				if (rtype(r1) != RTmp)
+					return;
+				bsset(as, r1.val);
+			}
 		}
 		u = fn->tmp[t].use;
 		u1 = &u[fn->tmp[t].nuse];
-- 
2.24.0

