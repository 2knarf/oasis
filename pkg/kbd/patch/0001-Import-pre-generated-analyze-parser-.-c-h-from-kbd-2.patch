From 35fbc125884bc2d8ebe05e25eb205d29c14b1309 Mon Sep 17 00:00:00 2001
From: Michael Forney <mforney@mforney.org>
Date: Mon, 16 May 2016 22:58:17 -0700
Subject: [PATCH] Import pre-generated {analyze,parser}.{c,h} from kbd-2.0.3
 distribution archive

This avoids a dependency on bison and flex.
---
 src/libkeymap/analyze.c | 2896 +++++++++++++++++++++++++++++++++++++++++++++++
 src/libkeymap/analyze.h |  368 ++++++
 src/libkeymap/parser.c  | 2238 ++++++++++++++++++++++++++++++++++++
 src/libkeymap/parser.h  |  172 +++
 4 files changed, 5674 insertions(+)
 create mode 100644 src/libkeymap/analyze.c
 create mode 100644 src/libkeymap/analyze.h
 create mode 100644 src/libkeymap/parser.c
 create mode 100644 src/libkeymap/parser.h

diff --git a/src/libkeymap/analyze.c b/src/libkeymap/analyze.c
new file mode 100644
index 0000000..527d507
--- /dev/null
+++ b/src/libkeymap/analyze.c
@@ -0,0 +1,2896 @@
+#line 15 "analyze.l"
+#include "keymap.h"
+int stack_push(struct lk_ctx *ctx, lkfile_t *fp, void *scanner);
+int stack_pop(struct lk_ctx *ctx, void *scanner);
+
+
+
+#line 9 "analyze.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 37
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+#ifndef YY_GNUC_PREREQ
+# if defined __GNUC__ && defined __GNUC_MINOR__
+#  define YY_GNUC_PREREQ(maj, min) \
+	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+# else
+#  define YY_GNUC_PREREQ(maj, min) 0
+# endif
+# if YY_GNUC_PREREQ(2, 5)
+#  define YY_ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+# else
+#  define YY_ATTRIBUTE_NORETURN /* __attribute__ ((__noreturn__)) */
+#  define YY_ATTRIBUTE_UNUSED /* __attribute__ ((__unused__)) */
+# endif
+#endif
+
+/* An opaque pointer. */
+#ifndef YY_TYPEDEF_YY_SCANNER_T
+#define YY_TYPEDEF_YY_SCANNER_T
+typedef void* yyscan_t;
+#endif
+
+/* For convenience, these vars (plus the bison vars far below)
+   are macros in the reentrant scanner. */
+#define yyin yyg->yyin_r
+#define yyout yyg->yyout_r
+#define yyextra yyg->yyextra_r
+#define yyleng yyg->yyleng_r
+#define yytext yyg->yytext_r
+#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
+#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
+#define yy_flex_debug yyg->yy_flex_debug_r
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yyg->yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yyg->yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin ,yyscanner )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = yyg->yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	yy_size_t yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
+                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]
+
+void yyrestart (FILE *input_file ,yyscan_t yyscanner );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size ,yyscan_t yyscanner );
+void yy_delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void yy_flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+void yypop_buffer_state (yyscan_t yyscanner );
+
+static void yyensure_buffer_stack (yyscan_t yyscanner );
+static void yy_load_buffer_state (yyscan_t yyscanner );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file ,yyscan_t yyscanner );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER ,yyscanner)
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len ,yyscan_t yyscanner );
+
+void *yyalloc (yy_size_t ,yyscan_t yyscanner );
+void *yyrealloc (void *,yy_size_t ,yyscan_t yyscanner );
+void yyfree (void * ,yyscan_t yyscanner );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (yyscanner); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (yyscanner); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define yywrap(yyscanner) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+typedef int yy_state_type;
+
+#define yytext_ptr yytext_r
+
+static yy_state_type yy_get_previous_state (yyscan_t yyscanner );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  ,yyscan_t yyscanner);
+static int yy_get_next_buffer (yyscan_t yyscanner );
+static void yy_fatal_error (yyconst char msg[] ,yyscan_t yyscanner ) YY_ATTRIBUTE_NORETURN;
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yyg->yytext_ptr = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	yyg->yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yyg->yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 48
+#define YY_END_OF_BUFFER 49
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[504] =
+    {   0,
+        0,    0,    0,    0,   45,   45,    0,    0,   49,   47,
+        6,    5,   47,   40,   47,   16,   15,   14,   12,   12,
+        8,   47,   47,   47,   47,   47,   47,   47,   47,   47,
+       47,   47,   47,   47,   47,   47,   47,   47,   47,   47,
+       47,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   45,   46,   48,    3,   48,    6,    0,    7,    0,
+        0,   12,    0,   12,    0,   33,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   35,
+        0,    0,    0,    0,    0,    0,   10,    0,    0,    0,
+
+        4,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   10,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   45,   42,   41,   43,   44,    0,    3,
+       39,    0,   39,    0,   12,   23,    0,   23,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   36,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       23,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   41,    2,
+       38,   37,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   41,   37,    0,    0,
+       24,    0,    0,    0,    0,   27,   28,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   20,
+       21,    0,   21,    0,    0,   34,    0,    0,    0,    0,
+        0,    0,    0,   21,    0,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   25,   26,    9,
+        9,   11,    0,    0,    0,    0,    0,    0,    0,    9,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,    9,
+        9,   13,   13,   13,   13,   13,   13,   13,    9,    0,
+        0,   17,   32,   22,    0,    0,   19,   18,   31,    0,
+        1,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,    0,    0,    0,    0,    0,    1,   13,
+       13,   13,   13,   13,    0,   29,   13,   13,    0,   13,
+
+       30,   13,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    1,    7,    1,
+        1,    1,    8,    9,   10,    1,    1,   11,   12,   12,
+       12,   12,   12,   12,   12,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   15,   16,   17,   18,   19,   20,
+       21,   22,   23,   24,   25,   26,   27,   28,   29,   30,
+       24,   31,   32,   33,   34,   24,   24,   35,   36,   24,
+        1,   37,    1,    1,   38,    1,   39,   16,   40,   41,
+
+       42,   43,   44,   45,   46,   24,   47,   48,   49,   50,
+       51,   52,   24,   53,   54,   55,   56,   24,   24,   35,
+       57,   24,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[58] =
+    {   0,
+        1,    1,    2,    1,    3,    1,    1,    1,    1,    1,
+        4,    4,    4,    1,    4,    4,    4,    4,    4,    4,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    3,    5,    4,    4,
+        4,    4,    4,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5
+    } ;
+
+static yyconst flex_int16_t yy_base[517] =
+    {   0,
+        0,    0,   57,    0,  110,  111,  721,  720,  724,  727,
+      721,  727,  719,  727,  684,  727,  727,  727,  106,  108,
+      727,   96,  110,   94,  110,   96,  105,  118,  105,  122,
+      717,  110,  123,  668,  668,  675,  666,  667,   82,  663,
+      659,  134,    0,  157,  106,  150,  131,  141,  158,  142,
+      162,  151,  156,  661,  661,  668,  659,  660,  130,  656,
+      652,    0,  727,  209,  727,  195,  703,  701,  727,  696,
+      211,  172,    0,  213,  154,  727,  164,  672,  686,  200,
+      669,  647,  659,  180,  644,  665,  642,  658,  636,  727,
+      677,  652,  667,  658,  642,  634,  727,    0,  652,  629,
+
+      727,  177,  182,  632,  644,  184,  629,  628,  640,  622,
+      639,  631,  623,  619,    0,  184,    0,  198,  644,  658,
+      208,  641,  619,  631,  191,  616,  637,  614,  630,  608,
+        0,  649,  624,  639,  630,  614,  606,    0,  624,  601,
+      205,  209,  604,  616,  194,  601,  600,  612,  594,  611,
+      603,  595,  591,    0,  727,  236,  727,  727,  201,  727,
+      727,  639,  638,  238,    0,  241,  242,  244,  612,  612,
+      612,  608,  614,  585,  585,  585,  581,  587,  727,  239,
+      241,  611,  587,  612,  608,  587,  583,    0,  613,  588,
+      245,  572,  572,  572,  568,  574,  573,   93,  574,  576,
+
+      572,  578,  253,  247,  257,  584,  584,  584,  580,  586,
+      557,  557,  557,  553,  559,    0,  244,  259,  583,  559,
+      584,  580,  559,  555,  585,  560,  259,  544,  544,  544,
+      540,  546,  545,  235,  546,  548,  544,  550,  261,  727,
+      727,  727,  293,  247,  557,  534,  533,  553,  552,  554,
+      551,  261,  262,  264,  530,  527,  276,  550,  563,  526,
+      537,  524,  535,  545,  522,  538,  542,  514,  518,    0,
+      541,  518,  512,  510,  509,  511,  508,  258,  504,  508,
+      519,  507,  501,  505,  506,  522,  275,  499,  498,  518,
+      517,  519,  516,  283,  278,  280,  495,  492,  289,  515,
+
+      528,  491,  502,  489,  500,  510,  487,  503,  507,  479,
+      483,  506,  483,  477,  475,  474,  476,  473,  269,  469,
+      473,  484,  472,  466,  470,  471,  727,  727,  511,  281,
+      727,  495,  497,  483,  485,  727,  727,  468,  467,  469,
+      468,  455,  457,  489,  476,  464,  452,  462,  450,  727,
+      293,  480,  297,  456,    0,  727,  454,  456,  443,  445,
+      454,  453,  441,  277,  448,    0,  294,  469,  471,  457,
+      459,    0,    0,  442,  441,  443,  442,  429,  431,  463,
+      450,  438,  426,  436,  424,    0,  305,  454,  307,  430,
+        0,  428,  430,  417,  419,  428,  427,  415,  289,  422,
+
+      317,  442,  431,  444,  436,  415,  414,  404,  403,  415,
+      408,  436,  422,  411,  398,  409,  396,  727,  727,  417,
+      394,  727,  401,  391,  403,  396,  401,  400,  387,  386,
+      319,  416,  405,  418,  410,  389,  388,  378,  377,  389,
+      382,  410,  396,  385,  372,  383,  370,    0,    0,  391,
+      368,  375,  365,  377,  370,  375,  374,  361,  360,  312,
+      393,  727,  727,  727,  369,  368,  727,  727,  727,  364,
+      396,  313,  370,    0,    0,    0,  329,  327,    0,    0,
+        0,  326,  363,  322,  330,  305,  304,  303,  354,  324,
+      321,  298,  297,  296,  312,  727,  313,    0,  332,  334,
+
+      727,    0,  727,  373,  378,  383,  388,  390,  395,  400,
+      405,  346,  340,  273,  134,  122
+    } ;
+
+static yyconst flex_int16_t yy_def[517] =
+    {   0,
+      503,    1,  503,    3,  504,  504,  505,  505,  503,  503,
+      503,  503,  506,  503,  507,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  509,  503,  503,  503,  510,  503,  506,  503,  503,
+      511,  503,  512,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  513,  503,  503,
+
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  509,  503,  503,  503,  503,  510,  503,
+      503,  503,  503,  503,  512,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  514,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+
+      503,  503,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  515,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  516,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  508,  508,  508,  508,  508,  508,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  508,  508,  508,  508,  508,  508,  508,  508,  508,
+      508,  508,  508,  503,  503,  503,  503,  503,  503,  508,
+      508,  508,  508,  508,  503,  503,  508,  508,  503,  508,
+
+      503,  508,    0,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503
+    } ;
+
+static yyconst flex_int16_t yy_nxt[785] =
+    {   0,
+       10,   11,   12,   13,   14,   13,   15,   16,   17,   18,
+       19,   20,   20,   21,   22,   10,   23,   10,   10,   24,
+       10,   10,   10,   10,   25,   10,   10,   10,   26,   27,
+       10,   28,   29,   30,   10,   10,   31,   10,   32,   33,
+       10,   10,   34,   10,   10,   35,   36,   10,   10,   10,
+       37,   38,   10,   39,   40,   41,   10,   10,   11,   12,
+       13,   14,   13,   15,   16,   17,   18,   19,   20,   20,
+       21,   42,   43,   44,   43,   43,   45,   43,   43,   43,
+       43,   46,   43,   43,   43,   47,   48,   43,   49,   50,
+       51,   43,   43,   31,   10,   52,   53,   43,   43,   54,
+
+       43,   43,   55,   56,   43,   43,   43,   57,   58,   43,
+       59,   60,   61,   43,   63,   63,   72,   72,   74,   74,
+       74,   75,   86,   90,   78,  422,  112,   76,   88,   98,
+       91,   79,  280,   97,  127,  102,  113,  355,   80,   93,
+       73,  281,   81,   77,   87,   90,   64,   64,   82,   76,
+       94,   89,   92,   99,   83,   97,  128,  103,  131,  116,
+       84,  104,   95,   76,   85,  117,  132,  105,  129,   98,
+      138,  119,   96,  106,  151,  100,  141,  107,  120,  134,
+      131,  118,   72,   72,  152,  121,  166,  117,  133,  122,
+      135,  130,  138,  139,  143,  123,  167,  160,  142,  160,
+
+      144,  124,  136,  160,  117,  240,  145,  125,  167,  167,
+      146,  126,  137,  155,  167,  140,  203,  163,  168,  156,
+      156,  164,  164,   74,   74,   74,  171,  172,  176,  177,
+      204,  167,  194,  195,  208,  209,  191,  204,  204,  213,
+      214,  204,  230,  231,  242,  157,  239,  239,  243,  243,
+      244,  244,  205,  244,  244,  258,  244,  260,  158,  204,
+      300,  245,  244,  227,  246,  259,  244,  261,  244,  330,
+      301,  327,  327,  286,  321,  302,  270,  288,  244,  244,
+      262,  244,  244,  322,  287,  303,  336,  247,  273,  263,
+      287,  337,  330,  338,  287,  340,  287,  367,  304,  328,
+
+      289,  336,  314,  329,  329,  336,  337,  305,  372,  374,
+      337,  376,  401,  373,  372,  339,  372,  341,  418,  373,
+      367,  373,  418,  419,  418,  431,  460,  419,  460,  419,
+      448,  375,  448,  377,  401,  449,  448,  449,  484,  490,
+      495,  449,  497,  188,  499,  500,  501,  431,  502,  165,
+      498,  498,  498,  498,  460,  489,  472,  496,  496,  496,
+      484,  490,  496,  495,  489,  497,  499,  500,  494,  493,
+      501,  492,  502,   62,   62,   62,   62,   62,   65,   65,
+       65,   65,   65,   68,   68,   68,   68,   68,   70,  491,
+       70,   70,   70,  115,  115,  154,  154,  489,  154,  154,
+
+      159,  159,  159,  159,  159,  162,  488,  162,  162,  162,
+      487,  486,  485,  481,  480,  479,  483,  476,  475,  474,
+      482,  481,  481,  480,  479,  480,  479,  480,  479,  476,
+      475,  474,  474,  478,  477,  476,  475,  474,  473,  469,
+      468,  467,  471,  464,  463,  462,  470,  469,  469,  468,
+      467,  468,  467,  468,  467,  464,  463,  462,  462,  466,
+      465,  464,  463,  462,  461,  459,  458,  457,  456,  455,
+      454,  453,  452,  451,  450,  447,  446,  445,  444,  443,
+      442,  441,  440,  439,  438,  437,  436,  435,  434,  433,
+      432,  430,  429,  428,  427,  426,  425,  424,  423,  421,
+
+      420,  417,  416,  415,  414,  413,  412,  411,  410,  409,
+      408,  407,  406,  405,  404,  403,  402,  328,  391,  400,
+      399,  386,  398,  397,  396,  395,  394,  393,  392,  366,
+      391,  391,  390,  389,  388,  387,  386,  386,  385,  384,
+      383,  382,  381,  380,  379,  378,  371,  370,  369,  368,
+      366,  366,  366,  356,  365,  364,  350,  363,  362,  361,
+      360,  359,  358,  357,  331,  356,  356,  354,  353,  352,
+      351,  350,  350,  349,  348,  347,  346,  345,  344,  343,
+      342,  335,  334,  333,  332,  331,  331,  331,  326,  325,
+      324,  323,  320,  319,  318,  317,  316,  315,  313,  312,
+
+      311,  310,  309,  308,  307,  306,  299,  298,  297,  296,
+      295,  294,  293,  292,  291,  290,  285,  284,  283,  282,
+      279,  278,  277,  276,  275,  274,  272,  271,  269,  268,
+      267,  266,  265,  264,  257,  256,  255,  254,  253,  252,
+      251,  250,  249,  248,  241,  241,  238,  237,  236,  235,
+      234,  233,  216,  232,  229,  228,  226,  225,  224,  223,
+      222,  221,  220,  219,  218,  217,  216,  216,  215,  212,
+      211,  210,  207,  206,  202,  201,  200,  199,  198,  197,
+      179,  196,  193,  192,  190,  189,  187,  186,  185,  184,
+      183,  182,  181,  180,  179,  179,  178,  175,  174,  173,
+
+      170,  169,  161,   69,   67,  153,  138,  150,  131,  149,
+      148,  147,  114,   97,  111,   90,  110,  109,  108,  101,
+       71,   69,   67,  503,   66,   66,    9,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503
+    } ;
+
+static yyconst flex_int16_t yy_chk[785] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    5,    6,   19,   19,   20,   20,
+       20,   22,   24,   26,   23,  516,   39,   22,   25,   30,
+       27,   23,  198,   29,   45,   32,   39,  515,   23,   28,
+       19,  198,   23,   22,   24,   26,    5,    6,   23,   22,
+       28,   25,   27,   30,   23,   29,   45,   32,   47,   42,
+       23,   33,   28,   32,   23,   42,   48,   33,   46,   51,
+       50,   44,   28,   33,   59,   30,   52,   33,   44,   49,
+       47,   42,   72,   72,   59,   44,   75,   42,   48,   44,
+       49,   46,   50,   51,   53,   44,   77,   66,   52,   66,
+
+       53,   44,   49,  159,   52,  159,   53,   44,   75,  102,
+       53,   44,   49,   64,  103,   51,  116,   71,   77,   64,
+       64,   71,   71,   74,   74,   74,   80,   80,   84,   84,
+      118,  102,  106,  106,  121,  121,  103,  141,  116,  125,
+      125,  142,  145,  145,  164,   64,  156,  156,  164,  164,
+      166,  167,  118,  168,  191,  180,  204,  181,   64,  141,
+      217,  166,  203,  142,  168,  180,  205,  181,  227,  244,
+      217,  239,  239,  203,  234,  218,  514,  205,  166,  167,
+      181,  168,  191,  234,  204,  218,  252,  168,  191,  181,
+      203,  252,  244,  253,  205,  254,  227,  287,  218,  243,
+
+      205,  257,  227,  243,  243,  278,  257,  218,  294,  295,
+      278,  296,  330,  294,  299,  253,  319,  254,  351,  299,
+      287,  319,  353,  351,  364,  367,  401,  353,  431,  364,
+      387,  295,  389,  296,  330,  387,  399,  389,  460,  472,
+      484,  399,  490,  513,  495,  497,  499,  367,  500,  512,
+      494,  493,  492,  491,  401,  489,  431,  488,  487,  486,
+      460,  472,  485,  484,  483,  490,  495,  497,  482,  478,
+      499,  477,  500,  504,  504,  504,  504,  504,  505,  505,
+      505,  505,  505,  506,  506,  506,  506,  506,  507,  473,
+      507,  507,  507,  508,  508,  509,  509,  471,  509,  509,
+
+      510,  510,  510,  510,  510,  511,  470,  511,  511,  511,
+      466,  465,  461,  459,  458,  457,  456,  455,  454,  453,
+      452,  451,  450,  447,  446,  445,  444,  443,  442,  441,
+      440,  439,  438,  437,  436,  435,  434,  433,  432,  430,
+      429,  428,  427,  426,  425,  424,  423,  421,  420,  417,
+      416,  415,  414,  413,  412,  411,  410,  409,  408,  407,
+      406,  405,  404,  403,  402,  400,  398,  397,  396,  395,
+      394,  393,  392,  390,  388,  385,  384,  383,  382,  381,
+      380,  379,  378,  377,  376,  375,  374,  371,  370,  369,
+      368,  365,  363,  362,  361,  360,  359,  358,  357,  354,
+
+      352,  349,  348,  347,  346,  345,  344,  343,  342,  341,
+      340,  339,  338,  335,  334,  333,  332,  329,  326,  325,
+      324,  323,  322,  321,  320,  318,  317,  316,  315,  314,
+      313,  312,  311,  310,  309,  308,  307,  306,  305,  304,
+      303,  302,  301,  300,  298,  297,  293,  292,  291,  290,
+      289,  288,  286,  285,  284,  283,  282,  281,  280,  279,
+      277,  276,  275,  274,  273,  272,  271,  269,  268,  267,
+      266,  265,  264,  263,  262,  261,  260,  259,  258,  256,
+      255,  251,  250,  249,  248,  247,  246,  245,  238,  237,
+      236,  235,  233,  232,  231,  230,  229,  228,  226,  225,
+
+      224,  223,  222,  221,  220,  219,  215,  214,  213,  212,
+      211,  210,  209,  208,  207,  206,  202,  201,  200,  199,
+      197,  196,  195,  194,  193,  192,  190,  189,  187,  186,
+      185,  184,  183,  182,  178,  177,  176,  175,  174,  173,
+      172,  171,  170,  169,  163,  162,  153,  152,  151,  150,
+      149,  148,  147,  146,  144,  143,  140,  139,  137,  136,
+      135,  134,  133,  132,  130,  129,  128,  127,  126,  124,
+      123,  122,  120,  119,  114,  113,  112,  111,  110,  109,
+      108,  107,  105,  104,  100,   99,   96,   95,   94,   93,
+       92,   91,   89,   88,   87,   86,   85,   83,   82,   81,
+
+       79,   78,   70,   68,   67,   61,   60,   58,   57,   56,
+       55,   54,   41,   40,   38,   37,   36,   35,   34,   31,
+       15,   13,   11,    9,    8,    7,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503,  503,  503,  503,  503,  503,  503,
+      503,  503,  503,  503
+    } ;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+#line 1 "analyze.l"
+#line 2 "analyze.l"
+#include <stdlib.h>
+#include <unistd.h> /* readlink */
+
+#include "nls.h"
+#include "kbd.h"
+#include "contextP.h"
+#include "ksyms.h"
+#include "paths.h"
+
+#include "parser.h"
+
+#define YY_NO_INPUT 1
+#line 32 "analyze.l"
+int
+stack_push(struct lk_ctx *ctx, lkfile_t *fp, void *scanner)
+{
+	int i = 0;
+
+	while (ctx->stack[i]) i++;
+
+	if (i == MAX_INCLUDE_DEPTH) {
+		ERR(ctx, _("includes are nested too deeply"));
+		return -1;
+	}
+
+	ctx->stack[i] = fp;
+
+	yypush_buffer_state(yy_create_buffer(fp->fd,YY_BUF_SIZE,scanner),scanner);
+	return 0;
+}
+
+int
+stack_pop(struct lk_ctx *ctx, void *scanner)
+{
+	int i = 0;
+
+	while (ctx->stack[i]) i++;
+	if (!i)
+		return 0;
+	i--;
+
+	/*
+	 * The top of stack is input file for library. No need to close it.
+	 */
+	if (i) {
+		lk_fpclose(ctx->stack[i]);
+		free(ctx->stack[i]);
+	}
+	ctx->stack[i] = NULL;
+
+	yypop_buffer_state(scanner);
+	return 0;
+}
+
+/*
+ * Where shall we look for an include file?
+ * Current strategy (undocumented, may change):
+ *
+ * 1. Look for a user-specified LOADKEYS_INCLUDE_PATH
+ * 2. Try . and ../include and ../../include
+ * 3. Try D and D/../include and D/../../include
+ *    where D is the directory from where we are loading the current file.
+ * 4. Try KD/include and KD/#/include where KD = DATADIR/KEYMAPDIR.
+ *
+ * Expected layout:
+ * KD has subdirectories amiga, atari, i386, mac, sun, include
+ * KD/include contains architecture-independent stuff
+ * like strings and iso-8859-x compose tables.
+ * KD/i386 has subdirectories qwerty, ... and include;
+ * this latter include dir contains stuff with keycode=...
+ *
+ * (Of course, if the present setup turns out to be reasonable,
+ * then later also the other architectures will grow and get
+ * subdirectories, and the hard-coded i386 below will go again.)
+ *
+ * People that dislike a dozen lookups for loadkeys
+ * can easily do "loadkeys file_with_includes; dumpkeys > my_keymap"
+ * and afterwards use only "loadkeys /fullpath/mykeymap", where no
+ * lookups are required.
+ */
+static const char *const include_dirpath0[] = { "", 0 };
+static const char *const include_dirpath1[] = { "", "../include/", "../../include/", 0 };
+static const char *const include_dirpath3[] = {
+	DATADIR "/" KEYMAPDIR "/include/",
+	DATADIR "/" KEYMAPDIR "/i386/include/",
+	DATADIR "/" KEYMAPDIR "/mac/include/", 0
+};
+
+static const char *const include_suffixes[] = { "", ".inc", 0 };
+
+static int
+find_incl_file_near_fn(struct lk_ctx *ctx, char *s, char *fn, lkfile_t *fp)
+{
+	const char *include_dirpath2[] = { 0, 0, 0, 0 };
+	char *t, *te, *t1 = NULL, *t2 = NULL;
+	int len, rc = 1;
+
+	if (!fn)
+		return 1;
+
+	t = strdup(fn);
+	if (t == NULL)
+		goto nomem;
+
+	te = strrchr(t, '/');
+	if (te) {
+		te[1] = 0;
+		len = strlen(t);
+		include_dirpath2[0] = t;
+		include_dirpath2[1] = t1 = malloc(len + 12);
+		include_dirpath2[2] = t2 = malloc(len + 15);
+
+		if (t1 == NULL || t2 == NULL)
+			goto nomem;
+
+		strcpy(t1, t);
+		strcat(t1, "../include/");
+		strcpy(t2, t);
+		strcat(t2, "../../include/");
+		rc = lk_findfile(s, include_dirpath2, include_suffixes, fp);
+		free(t1);
+		free(t2);
+	}
+	free(t);
+	return rc;
+
+nomem:	ERR(ctx, _("out of memory"));
+	if (t1) free(t1);
+	if (t2) free(t2);
+	if (t)  free(t);
+	return -1;
+}
+
+static int
+find_standard_incl_file(struct lk_ctx *ctx, char *s, lkfile_t *fp)
+{
+	char *pathname;
+	int rc = 1;
+	int i = 0;
+
+	while (ctx->stack[i]) i++;
+	if (i == 0)
+		return -1;
+	i--;
+	pathname = ctx->stack[i]->pathname;
+
+	if (lk_findfile(s, include_dirpath1, include_suffixes, fp)) {
+		if ((rc = find_incl_file_near_fn(ctx, s, pathname, fp)) == -1)
+			return rc;
+	}
+
+	/* If filename is a symlink, also look near its target. */
+	if (rc) {
+		char buf[MAXPATHLEN], path[MAXPATHLEN], *ptr;
+		unsigned int n;
+
+		n = readlink(pathname, buf, sizeof(buf));
+		if (n > 0 && n < sizeof(buf)) {
+			buf[n] = 0;
+			if (buf[0] == '/') {
+				rc = find_incl_file_near_fn(ctx, s, buf, fp);
+
+			} else if (strlen(pathname) + n < sizeof(path)) {
+				strcpy(path, pathname);
+				path[sizeof(path) - 1] = 0;
+				ptr = strrchr(path, '/');
+				if (ptr)
+					ptr[1] = 0;
+				strcat(path, buf);
+				rc = find_incl_file_near_fn(ctx, s, path, fp);
+			}
+		}
+	}
+
+	if (rc)
+		rc = lk_findfile(s, include_dirpath3, include_suffixes, fp);
+	return rc;
+}
+
+static int
+find_incl_file(struct lk_ctx *ctx, char *s, lkfile_t *fp)
+{
+	char *ev;
+
+	if (!s || !*s)
+		return 1;
+
+	if (*s == '/')		/* no path required */
+		return (lk_findfile(s, include_dirpath0, include_suffixes, fp));
+
+	if ((ev = getenv("LOADKEYS_INCLUDE_PATH")) != NULL) {
+		/* try user-specified path */
+		const char *user_dir[2] = { 0, 0 };
+		while (ev) {
+			int rc;
+			char *t = strchr(ev, ':');
+			char sv = 0;
+			if (t) {
+				sv = *t;
+				*t = 0;
+			}
+			user_dir[0] = ev;
+			if (*ev)
+				rc = lk_findfile(s, user_dir, include_suffixes, fp);
+			else	/* empty string denotes system path */
+				rc = find_standard_incl_file(ctx, s, fp);
+
+			if (rc <= 0)
+				return rc;
+			if (t)
+				*t++ = sv;
+			ev = t;
+		}
+		return 1;
+	}
+	return find_standard_incl_file(ctx, s, fp);
+}
+
+static int
+open_include(struct lk_ctx *ctx, char *s, yyscan_t scanner)
+{
+	int rc;
+	lkfile_t *fp;
+
+	INFO(ctx, _("switching to %s"), s);
+
+	fp = malloc(sizeof(lkfile_t));
+	if (!fp) {
+		ERR(ctx, _("out of memory"));
+		return -1;
+	}
+	memset(fp, 0, sizeof(lkfile_t));
+
+	rc = find_incl_file(ctx, s, fp);
+	if (rc > 0) {
+		ERR(ctx, _("cannot open include file %s"), s);
+		free(s);
+		return -1;
+	} else if (rc == -1) {
+		free(s);
+		return -1;
+	}
+
+	free(s);
+
+	return stack_push(ctx, fp, scanner);
+}
+
+
+
+
+#line 1048 "analyze.c"
+
+#define INITIAL 0
+#define RVALUE 1
+#define STR 2
+#define INCLSTR 3
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#define YY_EXTRA_TYPE struct lk_ctx *
+
+/* Holds the entire state of the reentrant scanner. */
+struct yyguts_t
+    {
+
+    /* User-defined. Not touched by flex. */
+    YY_EXTRA_TYPE yyextra_r;
+
+    /* The rest are the same as the globals declared in the non-reentrant scanner. */
+    FILE *yyin_r, *yyout_r;
+    size_t yy_buffer_stack_top; /**< index of top of stack. */
+    size_t yy_buffer_stack_max; /**< capacity of stack. */
+    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
+    char yy_hold_char;
+    yy_size_t yy_n_chars;
+    yy_size_t yyleng_r;
+    char *yy_c_buf_p;
+    int yy_init;
+    int yy_start;
+    int yy_did_buffer_switch_on_eof;
+    int yy_start_stack_ptr;
+    int yy_start_stack_depth;
+    int *yy_start_stack;
+    yy_state_type yy_last_accepting_state;
+    char* yy_last_accepting_cpos;
+
+    int yylineno_r;
+    int yy_flex_debug_r;
+
+    char *yytext_r;
+    int yy_more_flag;
+    int yy_more_len;
+
+    YYSTYPE * yylval_r;
+
+    }; /* end struct yyguts_t */
+
+static int yy_init_globals (yyscan_t yyscanner );
+
+    /* This must go here because YYSTYPE and YYLTYPE are included
+     * from bison output in section 1.*/
+    #    define yylval yyg->yylval_r
+    
+int yylex_init (yyscan_t* scanner);
+
+int yylex_init_extra (YY_EXTRA_TYPE user_defined,yyscan_t* scanner);
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (yyscan_t yyscanner );
+
+int yyget_debug (yyscan_t yyscanner );
+
+void yyset_debug (int debug_flag ,yyscan_t yyscanner );
+
+YY_EXTRA_TYPE yyget_extra (yyscan_t yyscanner );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );
+
+FILE *yyget_in (yyscan_t yyscanner );
+
+void yyset_in  (FILE * in_str ,yyscan_t yyscanner );
+
+FILE *yyget_out (yyscan_t yyscanner );
+
+void yyset_out  (FILE * out_str ,yyscan_t yyscanner );
+
+yy_size_t yyget_leng (yyscan_t yyscanner );
+
+char *yyget_text (yyscan_t yyscanner );
+
+int yyget_lineno (yyscan_t yyscanner );
+
+void yyset_lineno (int line_number ,yyscan_t yyscanner );
+
+int yyget_column  (yyscan_t yyscanner );
+
+void yyset_column (int column_no ,yyscan_t yyscanner );
+
+YYSTYPE * yyget_lval (yyscan_t yyscanner );
+
+void yyset_lval (YYSTYPE * yylval_param ,yyscan_t yyscanner );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (yyscan_t yyscanner );
+#else
+extern int yywrap (yyscan_t yyscanner );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (yyscan_t yyscanner );
+#else
+static int input (yyscan_t yyscanner );
+#endif
+
+#endif
+
+    static void yy_push_state (int new_state ,yyscan_t yyscanner);
+    
+    static void yy_pop_state (yyscan_t yyscanner );
+    
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex \
+               (YYSTYPE * yylval_param ,yyscan_t yyscanner);
+
+#define YY_DECL int yylex \
+               (YYSTYPE * yylval_param , yyscan_t yyscanner)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+#line 306 "analyze.l"
+
+
+#line 1291 "analyze.c"
+
+    yylval = yylval_param;
+
+	if ( !yyg->yy_init )
+		{
+		yyg->yy_init = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yyg->yy_start )
+			yyg->yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack (yyscanner);
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
+		}
+
+		yy_load_buffer_state(yyscanner );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yyg->yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yyg->yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yyg->yy_start;
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
+			if ( yy_accept[yy_current_state] )
+				{
+				yyg->yy_last_accepting_state = yy_current_state;
+				yyg->yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 504 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 503 );
+		yy_cp = yyg->yy_last_accepting_cpos;
+		yy_current_state = yyg->yy_last_accepting_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yyg->yy_hold_char;
+			yy_cp = yyg->yy_last_accepting_cpos;
+			yy_current_state = yyg->yy_last_accepting_state;
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 308 "analyze.l"
+{
+				yy_push_state(INCLSTR, yyscanner);
+			}
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 311 "analyze.l"
+{
+				char *s = strndup(yytext+1, strlen(yytext)-2);
+				if (s == NULL) {
+					ERR(yyextra, _("out of memory"));
+					return(ERROR);
+				}
+
+				if (open_include(yyextra, s, yyscanner) == -1)
+					return(ERROR);
+
+				while (((struct yyguts_t*)yyscanner)->yy_start_stack_ptr) {
+					yy_pop_state(yyscanner);
+				}
+			}
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 325 "analyze.l"
+{
+				ERR(yyextra, _("expected filename between quotes"));
+				return(ERROR);
+			}
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(RVALUE):
+case YY_STATE_EOF(STR):
+case YY_STATE_EOF(INCLSTR):
+#line 329 "analyze.l"
+{
+				stack_pop(yyextra, yyscanner);
+				if (!YY_CURRENT_BUFFER)
+					yyterminate();
+			}
+	YY_BREAK
+case 4:
+/* rule 4 can match eol */
+YY_RULE_SETUP
+#line 334 "analyze.l"
+{
+				yyset_lineno(yyget_lineno(yyscanner) + 1,yyscanner);
+			}
+	YY_BREAK
+case 5:
+/* rule 5 can match eol */
+YY_RULE_SETUP
+#line 337 "analyze.l"
+{
+				yyset_lineno(yyget_lineno(yyscanner) + 1,yyscanner);
+
+				while (((struct yyguts_t*)yyscanner)->yy_start_stack_ptr) {
+					yy_pop_state(yyscanner);
+				}
+				return(EOL);
+			}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 345 "analyze.l"
+; /* do nothing */
+	YY_BREAK
+case 7:
+/* rule 7 can match eol */
+*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
+yyg->yy_c_buf_p = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up yytext again */
+YY_RULE_SETUP
+#line 346 "analyze.l"
+; /* do nothing */
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 347 "analyze.l"
+{
+				yy_push_state(RVALUE, yyscanner);
+				lk_array_empty(yyextra->key_line);
+				return(EQUALS);
+			}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 352 "analyze.l"
+{
+				yy_push_state(RVALUE, yyscanner);
+				return(STRING);
+			}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 356 "analyze.l"
+{
+				yy_push_state(RVALUE, yyscanner);
+				return(TO);
+			}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 360 "analyze.l"
+{
+				yylval->num = strtol(yytext + 1, NULL, 16);
+				if (yylval->num >= 0xf000) {
+					ERR(yyextra, _("unicode keysym out of range: %s"),
+						yytext);
+					return(ERROR);
+				}
+				return(UNUMBER);
+			}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 369 "analyze.l"
+{
+				yylval->num = strtol(yytext, NULL, 0);
+				return(NUMBER);
+			}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 373 "analyze.l"
+{	return((yylval->num = ksymtocode(yyextra, yytext, TO_AUTO)) == -1 ? ERROR : LITERAL);	}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 374 "analyze.l"
+{	return(DASH);		}
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 375 "analyze.l"
+{	return(COMMA);		}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 376 "analyze.l"
+{	return(PLUS);		}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 377 "analyze.l"
+{	return(CHARSET);	}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 378 "analyze.l"
+{	return(KEYMAPS);	}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 379 "analyze.l"
+{	return(KEYCODE);	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 380 "analyze.l"
+{	return(PLAIN);		}
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 381 "analyze.l"
+{	return(SHIFT);		}
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 382 "analyze.l"
+{	return(CONTROL);	}
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 383 "analyze.l"
+{	return(ALT);		}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 384 "analyze.l"
+{	return(ALTGR);		}
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 385 "analyze.l"
+{	return(SHIFTL);		}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 386 "analyze.l"
+{	return(SHIFTR);		}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 387 "analyze.l"
+{	return(CTRLL);		}
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 388 "analyze.l"
+{	return(CTRLR);		}
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 389 "analyze.l"
+{	return(CAPSSHIFT);	}
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 390 "analyze.l"
+{	return(ALT_IS_META);	}
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 391 "analyze.l"
+{	return(STRINGS);	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 392 "analyze.l"
+{	return(COMPOSE);	}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 393 "analyze.l"
+{	return(AS);		}
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 394 "analyze.l"
+{	return(USUAL);		}
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 395 "analyze.l"
+{	return(ON);		}
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 396 "analyze.l"
+{	return(FOR);		}
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 397 "analyze.l"
+{
+				yylval->num = strtol(yytext + 2, NULL, 8);
+				return(CCHAR);
+			}
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 401 "analyze.l"
+{
+				yylval->num = (unsigned char) yytext[2];
+				return(CCHAR);
+			}
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 405 "analyze.l"
+{
+				yylval->num = (unsigned char) yytext[1];
+				return(CCHAR);
+			}
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 409 "analyze.l"
+{
+				yylval->str.data[0] = '\0';
+				yylval->str.len = 0;
+
+				yy_push_state(STR, yyscanner);
+			}
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 415 "analyze.l"
+{
+				if (yylval->str.len == MAX_PARSER_STRING) {
+					ERR(yyextra, _("string too long"));
+					return(ERROR);
+				}
+				yylval->str.data[yylval->str.len++] = strtol(yytext + 1, NULL, 8);
+			}
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 422 "analyze.l"
+{
+				if (yylval->str.len == MAX_PARSER_STRING) {
+					ERR(yyextra, _("string too long"));
+					return(ERROR);
+				}
+				yylval->str.data[yylval->str.len++] = '"';
+			}
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 429 "analyze.l"
+{
+				if (yylval->str.len == MAX_PARSER_STRING) {
+					ERR(yyextra, _("string too long"));
+					return(ERROR);
+				}
+				yylval->str.data[yylval->str.len++] = '\\';
+			}
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 436 "analyze.l"
+{
+				if (yylval->str.len == MAX_PARSER_STRING) {
+					ERR(yyextra, _("string too long"));
+					return(ERROR);
+				}
+				yylval->str.data[yylval->str.len++] = '\n';
+			}
+	YY_BREAK
+case 45:
+/* rule 45 can match eol */
+YY_RULE_SETUP
+#line 443 "analyze.l"
+{
+				int len = strlen(yytext);
+
+				if (yylval->str.len + len >= MAX_PARSER_STRING) {
+					ERR(yyextra, _("string too long"));
+					return(ERROR);
+				}
+
+				strcpy((char *) yylval->str.data + yylval->str.len, yytext);
+				yylval->str.len += len;
+			}
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 454 "analyze.l"
+{
+				yylval->str.data[yylval->str.len] = '\0';
+				while (((struct yyguts_t*)yyscanner)->yy_start_stack_ptr) {
+					yy_pop_state(yyscanner);
+				}
+				return(STRLITERAL);
+			}
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 461 "analyze.l"
+{
+				return(ERROR);
+			}
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 464 "analyze.l"
+ECHO;
+	YY_BREAK
+#line 1735 "analyze.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yyg->yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state( yyscanner );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);
+
+			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yyg->yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yyg->yy_last_accepting_cpos;
+				yy_current_state = yyg->yy_last_accepting_state;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer( yyscanner ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yyg->yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap(yyscanner ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yyg->yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yyg->yy_c_buf_p =
+					yyg->yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state( yyscanner );
+
+				yy_cp = yyg->yy_c_buf_p;
+				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yyg->yy_c_buf_p =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];
+
+				yy_current_state = yy_get_previous_state( yyscanner );
+
+				yy_cp = yyg->yy_c_buf_p;
+				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = yyg->yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;
+
+	else
+		{
+			yy_size_t num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
+
+			int yy_c_buf_p_offset =
+				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				yy_size_t new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			yyg->yy_n_chars, num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
+		}
+
+	if ( yyg->yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  ,yyscanner);
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	yyg->yy_n_chars += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	yy_current_state = yyg->yy_start;
+
+	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yyg->yy_last_accepting_state = yy_current_state;
+			yyg->yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 504 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
+{
+	register int yy_is_jam;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
+	register char *yy_cp = yyg->yy_c_buf_p;
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yyg->yy_last_accepting_state = yy_current_state;
+		yyg->yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 504 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 503);
+
+	(void)yyg;
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (yyscan_t yyscanner)
+#else
+    static int input  (yyscan_t yyscanner)
+#endif
+
+{
+	int c;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	*yyg->yy_c_buf_p = yyg->yy_hold_char;
+
+	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
+			/* This was really a NUL. */
+			*yyg->yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			yy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
+			++yyg->yy_c_buf_p;
+
+			switch ( yy_get_next_buffer( yyscanner ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin ,yyscanner);
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap(yyscanner ) )
+						return EOF;
+
+					if ( ! yyg->yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput(yyscanner);
+#else
+					return input(yyscanner);
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
+	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
+	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * @param yyscanner The scanner object.
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack (yyscanner);
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file ,yyscanner);
+	yy_load_buffer_state(yyscanner );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * @param yyscanner The scanner object.
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack (yyscanner);
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*yyg->yy_c_buf_p = yyg->yy_hold_char;
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state(yyscanner );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yyg->yy_did_buffer_switch_on_eof = 1;
+}
+
+static void yy_load_buffer_state  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	yyg->yy_hold_char = *yyg->yy_c_buf_p;
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * @param yyscanner The scanner object.
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2 ,yyscanner );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file ,yyscanner);
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * @param yyscanner The scanner object.
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf ,yyscanner );
+
+	yyfree((void *) b ,yyscanner );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)
+
+{
+	int oerrno = errno;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	yy_flush_buffer(b ,yyscanner);
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * @param yyscanner The scanner object.
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state(yyscanner );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  @param yyscanner The scanner object.
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack(yyscanner);
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*yyg->yy_c_buf_p = yyg->yy_hold_char;
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		yyg->yy_buffer_stack_top++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state(yyscanner );
+	yyg->yy_did_buffer_switch_on_eof = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  @param yyscanner The scanner object.
+ */
+void yypop_buffer_state (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if (yyg->yy_buffer_stack_top > 0)
+		--yyg->yy_buffer_stack_top;
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state(yyscanner );
+		yyg->yy_did_buffer_switch_on_eof = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (yyscan_t yyscanner)
+{
+	yy_size_t num_to_alloc;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	if (!yyg->yy_buffer_stack) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								, yyscanner);
+		if ( ! yyg->yy_buffer_stack )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		yyg->yy_buffer_stack_max = num_to_alloc;
+		yyg->yy_buffer_stack_top = 0;
+		return;
+	}
+
+	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
+		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
+								(yyg->yy_buffer_stack,
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								, yyscanner);
+		if ( ! yyg->yy_buffer_stack )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
+		yyg->yy_buffer_stack_max = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * @param yyscanner The scanner object.
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b ,yyscanner );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * @param yyscanner The scanner object.
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * @param yyscanner The scanner object.
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	yy_size_t i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n ,yyscanner );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n ,yyscanner);
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+    static void yy_push_state (int  new_state , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	if ( yyg->yy_start_stack_ptr >= yyg->yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yyg->yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yyg->yy_start_stack_depth * sizeof( int );
+
+		if ( ! yyg->yy_start_stack )
+			yyg->yy_start_stack = (int *) yyalloc(new_size ,yyscanner );
+
+		else
+			yyg->yy_start_stack = (int *) yyrealloc((void *) yyg->yy_start_stack,new_size ,yyscanner );
+
+		if ( ! yyg->yy_start_stack )
+			YY_FATAL_ERROR( "out of memory expanding start-condition stack" );
+		}
+
+	yyg->yy_start_stack[yyg->yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+}
+
+    static void yy_pop_state  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	if ( --yyg->yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yyg->yy_start_stack[yyg->yy_start_stack_ptr]);
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner YY_ATTRIBUTE_UNUSED)
+{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = yyg->yy_hold_char; \
+		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
+		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
+		*yyg->yy_c_buf_p = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the user-defined data for this scanner.
+ * @param yyscanner The scanner object.
+ */
+YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yyextra;
+}
+
+/** Get the current line number.
+ * @param yyscanner The scanner object.
+ */
+int yyget_lineno  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    
+        if (! YY_CURRENT_BUFFER)
+            return 0;
+    
+    return yylineno;
+}
+
+/** Get the current column number.
+ * @param yyscanner The scanner object.
+ */
+int yyget_column  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    
+        if (! YY_CURRENT_BUFFER)
+            return 0;
+    
+    return yycolumn;
+}
+
+/** Get the input stream.
+ * @param yyscanner The scanner object.
+ */
+FILE *yyget_in  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yyin;
+}
+
+/** Get the output stream.
+ * @param yyscanner The scanner object.
+ */
+FILE *yyget_out  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yyout;
+}
+
+/** Get the length of the current token.
+ * @param yyscanner The scanner object.
+ */
+yy_size_t yyget_leng  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yyleng;
+}
+
+/** Get the current token.
+ * @param yyscanner The scanner object.
+ */
+
+char *yyget_text  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yytext;
+}
+
+/** Set the user-defined data. This data is never touched by the scanner.
+ * @param user_defined The data to be associated with this scanner.
+ * @param yyscanner The scanner object.
+ */
+void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yyextra = user_defined ;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * @param yyscanner The scanner object.
+ */
+void yyset_lineno (int  line_number , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+        /* lineno is only valid if an input buffer exists. */
+        if (! YY_CURRENT_BUFFER )
+           YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
+    
+    yylineno = line_number;
+}
+
+/** Set the current column.
+ * @param line_number
+ * @param yyscanner The scanner object.
+ */
+void yyset_column (int  column_no , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+        /* column is only valid if an input buffer exists. */
+        if (! YY_CURRENT_BUFFER )
+           YY_FATAL_ERROR( "yyset_column called with no buffer" );
+    
+    yycolumn = column_no;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * @param yyscanner The scanner object.
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yyout = out_str ;
+}
+
+int yyget_debug  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yy_flex_debug = bdebug ;
+}
+
+/* Accessor methods for yylval and yylloc */
+
+YYSTYPE * yyget_lval  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yylval;
+}
+
+void yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yylval = yylval_param;
+}
+
+/* User-visible API */
+
+/* yylex_init is special because it creates the scanner itself, so it is
+ * the ONLY reentrant function that doesn't take the scanner as the last argument.
+ * That's why we explicitly handle the declaration, instead of using our macros.
+ */
+
+int yylex_init(yyscan_t* ptr_yy_globals)
+
+{
+    if (ptr_yy_globals == NULL){
+        errno = EINVAL;
+        return 1;
+    }
+
+    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );
+
+    if (*ptr_yy_globals == NULL){
+        errno = ENOMEM;
+        return 1;
+    }
+
+    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
+    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
+
+    return yy_init_globals ( *ptr_yy_globals );
+}
+
+/* yylex_init_extra has the same functionality as yylex_init, but follows the
+ * convention of taking the scanner as the last argument. Note however, that
+ * this is a *pointer* to a scanner, as it will be allocated by this call (and
+ * is the reason, too, why this function also must handle its own declaration).
+ * The user defined value in the first argument will be available to yyalloc in
+ * the yyextra field.
+ */
+
+int yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
+
+{
+    struct yyguts_t dummy_yyguts;
+
+    yyset_extra (yy_user_defined, &dummy_yyguts);
+
+    if (ptr_yy_globals == NULL){
+        errno = EINVAL;
+        return 1;
+    }
+	
+    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
+	
+    if (*ptr_yy_globals == NULL){
+        errno = ENOMEM;
+        return 1;
+    }
+    
+    /* By setting to 0xAA, we expose bugs in
+    yy_init_globals. Leave at 0x00 for releases. */
+    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
+    
+    yyset_extra (yy_user_defined, *ptr_yy_globals);
+    
+    return yy_init_globals ( *ptr_yy_globals );
+}
+
+static int yy_init_globals (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    yyg->yy_buffer_stack = 0;
+    yyg->yy_buffer_stack_top = 0;
+    yyg->yy_buffer_stack_max = 0;
+    yyg->yy_c_buf_p = (char *) 0;
+    yyg->yy_init = 0;
+    yyg->yy_start = 0;
+
+    yyg->yy_start_stack_ptr = 0;
+    yyg->yy_start_stack_depth = 0;
+    yyg->yy_start_stack =  NULL;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state(yyscanner);
+	}
+
+	/* Destroy the stack itself. */
+	yyfree(yyg->yy_buffer_stack ,yyscanner);
+	yyg->yy_buffer_stack = NULL;
+
+    /* Destroy the start condition stack. */
+        yyfree(yyg->yy_start_stack ,yyscanner );
+        yyg->yy_start_stack = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( yyscanner);
+
+    /* Destroy the main struct (reentrant only). */
+    yyfree ( yyscanner , yyscanner );
+    yyscanner = NULL;
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner YY_ATTRIBUTE_UNUSED)
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner YY_ATTRIBUTE_UNUSED)
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size , yyscan_t yyscanner YY_ATTRIBUTE_UNUSED)
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner YY_ATTRIBUTE_UNUSED)
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr , yyscan_t yyscanner YY_ATTRIBUTE_UNUSED)
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 464 "analyze.l"
+
+
+
diff --git a/src/libkeymap/analyze.h b/src/libkeymap/analyze.h
new file mode 100644
index 0000000..eb8ea5d
--- /dev/null
+++ b/src/libkeymap/analyze.h
@@ -0,0 +1,368 @@
+#ifndef yyHEADER_H
+#define yyHEADER_H 1
+#define yyIN_HEADER 1
+
+#line 15 "/home/legion/scm/.kbd/kbd/src/libkeymap/analyze.l"
+#include "keymap.h"
+int stack_push(struct lk_ctx *ctx, lkfile_t *fp, void *scanner);
+int stack_pop(struct lk_ctx *ctx, void *scanner);
+
+
+
+#line 13 "/home/legion/scm/.kbd/kbd/src/libkeymap/analyze.h"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 37
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+#ifndef YY_GNUC_PREREQ
+# if defined __GNUC__ && defined __GNUC_MINOR__
+#  define YY_GNUC_PREREQ(maj, min) \
+	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+# else
+#  define YY_GNUC_PREREQ(maj, min) 0
+# endif
+# if YY_GNUC_PREREQ(2, 5)
+#  define YY_ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+# else
+#  define YY_ATTRIBUTE_NORETURN /* __attribute__ ((__noreturn__)) */
+#  define YY_ATTRIBUTE_UNUSED /* __attribute__ ((__unused__)) */
+# endif
+#endif
+
+/* An opaque pointer. */
+#ifndef YY_TYPEDEF_YY_SCANNER_T
+#define YY_TYPEDEF_YY_SCANNER_T
+typedef void* yyscan_t;
+#endif
+
+/* For convenience, these vars (plus the bison vars far below)
+   are macros in the reentrant scanner. */
+#define yyin yyg->yyin_r
+#define yyout yyg->yyout_r
+#define yyextra yyg->yyextra_r
+#define yyleng yyg->yyleng_r
+#define yytext yyg->yytext_r
+#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
+#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
+#define yy_flex_debug yyg->yy_flex_debug_r
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	yy_size_t yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+void yyrestart (FILE *input_file ,yyscan_t yyscanner );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size ,yyscan_t yyscanner );
+void yy_delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void yy_flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+void yypop_buffer_state (yyscan_t yyscanner );
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len ,yyscan_t yyscanner );
+
+void *yyalloc (yy_size_t ,yyscan_t yyscanner );
+void *yyrealloc (void *,yy_size_t ,yyscan_t yyscanner );
+void yyfree (void * ,yyscan_t yyscanner );
+
+/* Begin user sect3 */
+
+#define yywrap(yyscanner) 1
+#define YY_SKIP_YYWRAP
+
+#define yytext_ptr yytext_r
+
+#ifdef YY_HEADER_EXPORT_START_CONDITIONS
+#define INITIAL 0
+#define RVALUE 1
+#define STR 2
+#define INCLSTR 3
+
+#endif
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#define YY_EXTRA_TYPE struct lk_ctx *
+
+int yylex_init (yyscan_t* scanner);
+
+int yylex_init_extra (YY_EXTRA_TYPE user_defined,yyscan_t* scanner);
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (yyscan_t yyscanner );
+
+int yyget_debug (yyscan_t yyscanner );
+
+void yyset_debug (int debug_flag ,yyscan_t yyscanner );
+
+YY_EXTRA_TYPE yyget_extra (yyscan_t yyscanner );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );
+
+FILE *yyget_in (yyscan_t yyscanner );
+
+void yyset_in  (FILE * in_str ,yyscan_t yyscanner );
+
+FILE *yyget_out (yyscan_t yyscanner );
+
+void yyset_out  (FILE * out_str ,yyscan_t yyscanner );
+
+yy_size_t yyget_leng (yyscan_t yyscanner );
+
+char *yyget_text (yyscan_t yyscanner );
+
+int yyget_lineno (yyscan_t yyscanner );
+
+void yyset_lineno (int line_number ,yyscan_t yyscanner );
+
+int yyget_column  (yyscan_t yyscanner );
+
+void yyset_column (int column_no ,yyscan_t yyscanner );
+
+YYSTYPE * yyget_lval (yyscan_t yyscanner );
+
+void yyset_lval (YYSTYPE * yylval_param ,yyscan_t yyscanner );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (yyscan_t yyscanner );
+#else
+extern int yywrap (yyscan_t yyscanner );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);
+#endif
+
+#ifndef YY_NO_INPUT
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex \
+               (YYSTYPE * yylval_param ,yyscan_t yyscanner);
+
+#define YY_DECL int yylex \
+               (YYSTYPE * yylval_param , yyscan_t yyscanner)
+#endif /* !YY_DECL */
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+#undef YY_NEW_FILE
+#undef YY_FLUSH_BUFFER
+#undef yy_set_bol
+#undef yy_new_buffer
+#undef yy_set_interactive
+#undef YY_DO_BEFORE_ACTION
+
+#ifdef YY_DECL_IS_OURS
+#undef YY_DECL_IS_OURS
+#undef YY_DECL
+#endif
+
+#line 464 "/home/legion/scm/.kbd/kbd/src/libkeymap/analyze.l"
+
+
+#line 367 "/home/legion/scm/.kbd/kbd/src/libkeymap/analyze.h"
+#undef yyIN_HEADER
+#endif /* yyHEADER_H */
diff --git a/src/libkeymap/parser.c b/src/libkeymap/parser.c
new file mode 100644
index 0000000..62a9436
--- /dev/null
+++ b/src/libkeymap/parser.c
@@ -0,0 +1,2238 @@
+/* A Bison parser, made by GNU Bison 2.7.1.  */
+
+/* Bison implementation for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.7.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 1
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+/* Line 371 of yacc.c  */
+#line 12 "parser.y"
+
+#define YY_HEADER_EXPORT_START_CONDITIONS 1
+
+#include "nls.h"
+#include "kbd.h"
+
+#include "contextP.h"
+#include "ksyms.h"
+#include "modifiers.h"
+
+#include "parser.h"
+#include "analyze.h"
+
+/* Line 371 of yacc.c  */
+#line 82 "parser.c"
+
+# ifndef YY_NULL
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULL nullptr
+#  else
+#   define YY_NULL 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 1
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "y.tab.h".  */
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+/* "%code requires" blocks.  */
+/* Line 387 of yacc.c  */
+#line 26 "parser.y"
+
+#include "keymap.h"
+
+#ifndef STRDATA_STRUCT
+#define STRDATA_STRUCT
+#define MAX_PARSER_STRING 512
+struct strdata {
+	unsigned int len;
+	unsigned char data[MAX_PARSER_STRING];
+};
+#endif
+
+
+/* Line 387 of yacc.c  */
+#line 128 "parser.c"
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     EOL = 258,
+     NUMBER = 259,
+     LITERAL = 260,
+     CHARSET = 261,
+     KEYMAPS = 262,
+     KEYCODE = 263,
+     EQUALS = 264,
+     PLAIN = 265,
+     SHIFT = 266,
+     CONTROL = 267,
+     ALT = 268,
+     ALTGR = 269,
+     SHIFTL = 270,
+     SHIFTR = 271,
+     CTRLL = 272,
+     CTRLR = 273,
+     CAPSSHIFT = 274,
+     COMMA = 275,
+     DASH = 276,
+     STRING = 277,
+     STRLITERAL = 278,
+     COMPOSE = 279,
+     TO = 280,
+     CCHAR = 281,
+     ERROR = 282,
+     PLUS = 283,
+     UNUMBER = 284,
+     ALT_IS_META = 285,
+     STRINGS = 286,
+     AS = 287,
+     USUAL = 288,
+     ON = 289,
+     FOR = 290
+   };
+#endif
+/* Tokens.  */
+#define EOL 258
+#define NUMBER 259
+#define LITERAL 260
+#define CHARSET 261
+#define KEYMAPS 262
+#define KEYCODE 263
+#define EQUALS 264
+#define PLAIN 265
+#define SHIFT 266
+#define CONTROL 267
+#define ALT 268
+#define ALTGR 269
+#define SHIFTL 270
+#define SHIFTR 271
+#define CTRLL 272
+#define CTRLR 273
+#define CAPSSHIFT 274
+#define COMMA 275
+#define DASH 276
+#define STRING 277
+#define STRLITERAL 278
+#define COMPOSE 279
+#define TO 280
+#define CCHAR 281
+#define ERROR 282
+#define PLUS 283
+#define UNUMBER 284
+#define ALT_IS_META 285
+#define STRINGS 286
+#define AS 287
+#define USUAL 288
+#define ON 289
+#define FOR 290
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+/* Line 387 of yacc.c  */
+#line 58 "parser.y"
+
+	long long int num;
+	struct strdata str;
+
+
+/* Line 387 of yacc.c  */
+#line 219 "parser.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *scanner, struct lk_ctx *ctx);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+/* Line 390 of yacc.c  */
+#line 71 "parser.y"
+
+static int
+yyerror(yyscan_t scanner __attribute__ ((unused)),
+        struct lk_ctx *ctx, const char *s)
+{
+	ERR(ctx, "%s", s);
+	return 0;
+}
+
+static int
+strings_as_usual(struct lk_ctx *ctx)
+{
+	/*
+	 * 26 strings, mostly inspired by the VT100 family
+	 */
+	char *stringvalues[30] = {
+		/* F1 .. F20 */
+		"\033[[A",  "\033[[B",  "\033[[C",  "\033[[D",  "\033[[E",
+		"\033[17~", "\033[18~", "\033[19~", "\033[20~", "\033[21~",
+		"\033[23~", "\033[24~", "\033[25~", "\033[26~",
+		"\033[28~", "\033[29~",
+		"\033[31~", "\033[32~", "\033[33~", "\033[34~",
+		/* Find,    Insert,     Remove,     Select,     Prior */
+		"\033[1~",  "\033[2~",  "\033[3~",  "\033[4~",  "\033[5~",
+		/* Next,    Macro,      Help,       Do,         Pause */
+		"\033[6~",  0,          0,          0,          0
+	};
+	int i;
+
+	for (i = 0; i < 30; i++) {
+		if (stringvalues[i]) {
+			struct kbsentry ke;
+			ke.kb_func = i;
+			strncpy((char *)ke.kb_string, stringvalues[i],
+				sizeof(ke.kb_string));
+			ke.kb_string[sizeof(ke.kb_string) - 1] = 0;
+
+			if (lk_add_func(ctx, &ke) == -1)
+				return -1;
+		}
+	}
+	return 0;
+}
+
+static int
+compose_as_usual(struct lk_ctx *ctx, char *charset)
+{
+	if (charset && strcmp(charset, "iso-8859-1")) {
+		ERR(ctx, _("loadkeys: don't know how to compose for %s"), charset);
+		return -1;
+
+	} else {
+		struct ccc {
+			unsigned char c1, c2, c3;
+		} def_latin1_composes[68] = {
+			{ '`', 'A', 0300 }, { '`', 'a', 0340 },
+			{ '\'', 'A', 0301 }, { '\'', 'a', 0341 },
+			{ '^', 'A', 0302 }, { '^', 'a', 0342 },
+			{ '~', 'A', 0303 }, { '~', 'a', 0343 },
+			{ '"', 'A', 0304 }, { '"', 'a', 0344 },
+			{ 'O', 'A', 0305 }, { 'o', 'a', 0345 },
+			{ '0', 'A', 0305 }, { '0', 'a', 0345 },
+			{ 'A', 'A', 0305 }, { 'a', 'a', 0345 },
+			{ 'A', 'E', 0306 }, { 'a', 'e', 0346 },
+			{ ',', 'C', 0307 }, { ',', 'c', 0347 },
+			{ '`', 'E', 0310 }, { '`', 'e', 0350 },
+			{ '\'', 'E', 0311 }, { '\'', 'e', 0351 },
+			{ '^', 'E', 0312 }, { '^', 'e', 0352 },
+			{ '"', 'E', 0313 }, { '"', 'e', 0353 },
+			{ '`', 'I', 0314 }, { '`', 'i', 0354 },
+			{ '\'', 'I', 0315 }, { '\'', 'i', 0355 },
+			{ '^', 'I', 0316 }, { '^', 'i', 0356 },
+			{ '"', 'I', 0317 }, { '"', 'i', 0357 },
+			{ '-', 'D', 0320 }, { '-', 'd', 0360 },
+			{ '~', 'N', 0321 }, { '~', 'n', 0361 },
+			{ '`', 'O', 0322 }, { '`', 'o', 0362 },
+			{ '\'', 'O', 0323 }, { '\'', 'o', 0363 },
+			{ '^', 'O', 0324 }, { '^', 'o', 0364 },
+			{ '~', 'O', 0325 }, { '~', 'o', 0365 },
+			{ '"', 'O', 0326 }, { '"', 'o', 0366 },
+			{ '/', 'O', 0330 }, { '/', 'o', 0370 },
+			{ '`', 'U', 0331 }, { '`', 'u', 0371 },
+			{ '\'', 'U', 0332 }, { '\'', 'u', 0372 },
+			{ '^', 'U', 0333 }, { '^', 'u', 0373 },
+			{ '"', 'U', 0334 }, { '"', 'u', 0374 },
+			{ '\'', 'Y', 0335 }, { '\'', 'y', 0375 },
+			{ 'T', 'H', 0336 }, { 't', 'h', 0376 },
+			{ 's', 's', 0337 }, { '"', 'y', 0377 },
+			{ 's', 'z', 0337 }, { 'i', 'j', 0377 }
+		};
+		int i;
+		for (i = 0; i < 68; i++) {
+			struct lk_kbdiacr ptr;
+			struct ccc c = def_latin1_composes[i];
+
+			ptr.diacr  = c.c1;
+			ptr.base   = c.c2;
+			ptr.result = c.c3;
+
+			if (lk_append_compose(ctx, &ptr) == -1)
+				return -1;
+		}
+	}
+	return 0;
+}
+
+
+/* Line 390 of yacc.c  */
+#line 354 "parser.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if (! defined __GNUC__ || __GNUC__ < 2 \
+      || (__GNUC__ == 2 && __GNUC_MINOR__ < 5))
+#  define __attribute__(Spec) /* empty */
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(N) (N)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (YYID (0))
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   86
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  19
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  50
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  91
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     4,     7,     9,    11,    13,    15,    17,
+      19,    21,    23,    25,    29,    32,    37,    44,    49,    53,
+      57,    59,    63,    65,    71,    78,    85,    87,    89,    95,
+     102,   109,   112,   114,   116,   118,   120,   122,   124,   126,
+     128,   130,   132,   133,   136,   138,   140,   143,   145,   148,
+     150
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      37,     0,    -1,    -1,    37,    38,    -1,     3,    -1,    39,
+      -1,    40,    -1,    41,    -1,    42,    -1,    43,    -1,    49,
+      -1,    46,    -1,    47,    -1,     6,    23,     3,    -1,    30,
+       3,    -1,    31,    32,    33,     3,    -1,    24,    32,    33,
+      35,    23,     3,    -1,    24,    32,    33,     3,    -1,     7,
+      44,     3,    -1,    44,    20,    45,    -1,    45,    -1,     4,
+      21,     4,    -1,     4,    -1,    22,     5,     9,    23,     3,
+      -1,    24,    48,    48,    25,    48,     3,    -1,    24,    48,
+      48,    25,    54,     3,    -1,    26,    -1,    29,    -1,     8,
+       4,     9,    52,     3,    -1,    50,     8,     4,     9,    54,
+       3,    -1,    10,     8,     4,     9,    54,     3,    -1,    50,
+      51,    -1,    51,    -1,    11,    -1,    12,    -1,    13,    -1,
+      14,    -1,    15,    -1,    16,    -1,    17,    -1,    18,    -1,
+      19,    -1,    -1,    53,    52,    -1,    54,    -1,     4,    -1,
+      28,     4,    -1,    29,    -1,    28,    29,    -1,     5,    -1,
+      28,     5,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   180,   180,   181,   183,   184,   185,   186,   187,   188,
+     189,   190,   191,   193,   210,   215,   222,   227,   233,   238,
+     239,   241,   249,   255,   275,   285,   296,   297,   299,   359,
+     365,   372,   373,   375,   376,   377,   378,   379,   380,   381,
+     382,   383,   387,   388,   390,   396,   397,   398,   399,   400,
+     401
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 1
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "EOL", "NUMBER", "LITERAL", "CHARSET",
+  "KEYMAPS", "KEYCODE", "EQUALS", "PLAIN", "SHIFT", "CONTROL", "ALT",
+  "ALTGR", "SHIFTL", "SHIFTR", "CTRLL", "CTRLR", "CAPSSHIFT", "COMMA",
+  "DASH", "STRING", "STRLITERAL", "COMPOSE", "TO", "CCHAR", "ERROR",
+  "PLUS", "UNUMBER", "ALT_IS_META", "STRINGS", "AS", "USUAL", "ON", "FOR",
+  "$accept", "keytable", "line", "charsetline", "altismetaline",
+  "usualstringsline", "usualcomposeline", "keymapline", "range", "range0",
+  "strline", "compline", "compsym", "singleline", "modifiers", "modifier",
+  "rvalue0", "rvalue1", "rvalue", YY_NULL
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    36,    37,    37,    38,    38,    38,    38,    38,    38,
+      38,    38,    38,    39,    40,    41,    42,    42,    43,    44,
+      44,    45,    45,    46,    47,    47,    48,    48,    49,    49,
+      49,    50,    50,    51,    51,    51,    51,    51,    51,    51,
+      51,    51,    52,    52,    53,    54,    54,    54,    54,    54,
+      54
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     3,     2,     4,     6,     4,     3,     3,
+       1,     3,     1,     5,     6,     6,     1,     1,     5,     6,
+       6,     2,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     0,     2,     1,     1,     2,     1,     2,     1,
+       2
+};
+
+/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     1,     4,     0,     0,     0,     0,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,     0,     0,     0,
+       0,     3,     5,     6,     7,     8,     9,    11,    12,    10,
+       0,    32,     0,    22,     0,    20,     0,     0,     0,    26,
+      27,     0,     0,    14,     0,     0,    31,    13,     0,    18,
+       0,    42,     0,     0,     0,     0,     0,     0,    21,    19,
+      45,    49,     0,    47,     0,    42,    44,     0,     0,    17,
+       0,     0,    15,     0,    46,    50,    48,    28,    43,     0,
+      23,     0,    27,     0,     0,     0,    30,    16,    24,    25,
+      29
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,    21,    22,    23,    24,    25,    26,    34,    35,
+      27,    28,    42,    29,    30,    31,    64,    65,    66
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -42
+static const yytype_int8 yypact[] =
+{
+     -42,     3,   -42,   -42,   -21,     4,     8,    -1,   -42,   -42,
+     -42,   -42,   -42,   -42,   -42,   -42,   -42,    26,    12,    37,
+      10,   -42,   -42,   -42,   -42,   -42,   -42,   -42,   -42,   -42,
+      50,   -42,    47,    30,    34,   -42,    43,    49,    46,   -42,
+     -42,    23,    20,   -42,    24,    55,   -42,   -42,    66,   -42,
+       4,    19,    62,    51,    -3,    48,    69,    67,   -42,   -42,
+     -42,   -42,    31,   -42,    72,    19,   -42,    19,    74,   -42,
+      56,     0,   -42,    19,   -42,   -42,   -42,   -42,   -42,    75,
+     -42,    77,   -42,    78,    79,    80,   -42,   -42,   -42,   -42,
+     -42
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -42,   -42,   -42,   -42,   -42,   -42,   -42,   -42,   -42,    35,
+     -42,   -42,   -41,   -42,   -42,    54,    21,   -42,   -28
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const yytype_uint8 yytable[] =
+{
+      69,    55,    32,     2,    60,    61,     3,    37,    33,     4,
+       5,     6,    36,     7,     8,     9,    10,    11,    12,    13,
+      14,    15,    16,    60,    61,    17,    39,    18,    62,    82,
+      83,    38,    70,    19,    20,    74,    75,    49,    39,    79,
+      43,    40,    44,    84,    41,    85,    39,    62,    63,    40,
+      47,    48,    51,    52,    50,    53,    54,    56,    45,    57,
+      76,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+      58,    67,    72,    71,    68,    77,    73,    80,    86,    81,
+      87,    88,    89,    90,    46,    59,    78
+};
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-42)))
+
+#define yytable_value_is_error(Yytable_value) \
+  YYID (0)
+
+static const yytype_uint8 yycheck[] =
+{
+       3,    42,    23,     0,     4,     5,     3,     8,     4,     6,
+       7,     8,     4,    10,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,     4,     5,    22,    26,    24,    28,    29,
+      71,     5,    35,    30,    31,     4,     5,     3,    26,    67,
+       3,    29,    32,    71,    32,    73,    26,    28,    29,    29,
+       3,    21,     9,     4,    20,     9,    33,    33,     8,     4,
+      29,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+       4,     9,     3,    25,    23,     3,     9,     3,     3,    23,
+       3,     3,     3,     3,    30,    50,    65
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    37,     0,     3,     6,     7,     8,    10,    11,    12,
+      13,    14,    15,    16,    17,    18,    19,    22,    24,    30,
+      31,    38,    39,    40,    41,    42,    43,    46,    47,    49,
+      50,    51,    23,     4,    44,    45,     4,     8,     5,    26,
+      29,    32,    48,     3,    32,     8,    51,     3,    21,     3,
+      20,     9,     4,     9,    33,    48,    33,     4,     4,    45,
+       4,     5,    28,    29,    52,    53,    54,     9,    23,     3,
+      35,    25,     3,     9,     4,     5,    29,     3,    52,    54,
+       3,    23,    29,    48,    54,    54,     3,     3,     3,     3,
+       3
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (scanner, ctx, YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+/* Error token number */
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (&yylval, YYLEX_PARAM)
+#else
+# define YYLEX yylex (&yylval, scanner)
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value, scanner, ctx); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, void *scanner, struct lk_ctx *ctx)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep, scanner, ctx)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+    void *scanner;
+    struct lk_ctx *ctx;
+#endif
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+  YYUSE (scanner);
+  YYUSE (ctx);
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, void *scanner, struct lk_ctx *ctx)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep, scanner, ctx)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+    void *scanner;
+    struct lk_ctx *ctx;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep, scanner, ctx);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule, void *scanner, struct lk_ctx *ctx)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule, scanner, ctx)
+    YYSTYPE *yyvsp;
+    int yyrule;
+    void *scanner;
+    struct lk_ctx *ctx;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       , scanner, ctx);
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule, scanner, ctx); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULL;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - Assume YYFAIL is not used.  It's too flawed to consider.  See
+       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
+       for details.  YYERROR is fine as it does not invoke this
+       function.
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *scanner, struct lk_ctx *ctx)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep, scanner, ctx)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+    void *scanner;
+    struct lk_ctx *ctx;
+#endif
+{
+  YYUSE (yyvaluep);
+  YYUSE (scanner);
+  YYUSE (ctx);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YYUSE (yytype);
+}
+
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *scanner, struct lk_ctx *ctx)
+#else
+int
+yyparse (scanner, ctx)
+    void *scanner;
+    struct lk_ctx *ctx;
+#endif
+#endif
+{
+/* The lookahead symbol.  */
+int yychar;
+
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+/* Default value used for initialization, for pacifying older GCCs
+   or non-GCC compilers.  */
+static YYSTYPE yyval_default;
+# define YY_INITIAL_VALUE(Value) = Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);
+
+    /* Number of syntax errors so far.  */
+    int yynerrs;
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 13:
+/* Line 1787 of yacc.c  */
+#line 194 "parser.y"
+    {
+				if (lk_set_charset(ctx, (char *) (yyvsp[(2) - (3)].str).data)) {
+					ERR(ctx,
+						_("unknown charset %s - ignoring charset request\n"),
+						(char *) (yyvsp[(2) - (3)].str).data);
+					YYERROR;
+				}
+				ctx->keywords |= LK_KEYWORD_CHARSET;
+
+				/* Unicode: The first 256 code points were made
+				   identical to the content of ISO 8859-1 */
+				if (ctx->flags & LK_FLAG_PREFER_UNICODE &&
+				    !strcasecmp((char *) (yyvsp[(2) - (3)].str).data, "iso-8859-1"))
+					ctx->flags ^= LK_FLAG_PREFER_UNICODE;
+			}
+    break;
+
+  case 14:
+/* Line 1787 of yacc.c  */
+#line 211 "parser.y"
+    {
+				ctx->keywords |= LK_KEYWORD_ALTISMETA;
+			}
+    break;
+
+  case 15:
+/* Line 1787 of yacc.c  */
+#line 216 "parser.y"
+    {
+				if (strings_as_usual(ctx) == -1)
+					YYERROR;
+				ctx->keywords |= LK_KEYWORD_STRASUSUAL;
+			}
+    break;
+
+  case 16:
+/* Line 1787 of yacc.c  */
+#line 223 "parser.y"
+    {
+				if (compose_as_usual(ctx, (char *) (yyvsp[(5) - (6)].str).data) == -1)
+					YYERROR;
+			}
+    break;
+
+  case 17:
+/* Line 1787 of yacc.c  */
+#line 228 "parser.y"
+    {
+				if (compose_as_usual(ctx, 0) == -1)
+					YYERROR;
+			}
+    break;
+
+  case 18:
+/* Line 1787 of yacc.c  */
+#line 234 "parser.y"
+    {
+				ctx->keywords |= LK_KEYWORD_KEYMAPS;
+			}
+    break;
+
+  case 21:
+/* Line 1787 of yacc.c  */
+#line 242 "parser.y"
+    {
+				int i;
+				for (i = (yyvsp[(1) - (3)].num); i <= (yyvsp[(3) - (3)].num); i++) {
+					if (lk_add_map(ctx, i) == -1)
+						YYERROR;
+				}
+			}
+    break;
+
+  case 22:
+/* Line 1787 of yacc.c  */
+#line 250 "parser.y"
+    {
+				if (lk_add_map(ctx, (yyvsp[(1) - (1)].num)) == -1)
+					YYERROR;
+			}
+    break;
+
+  case 23:
+/* Line 1787 of yacc.c  */
+#line 256 "parser.y"
+    {
+				struct kbsentry ke;
+
+				if (KTYP((yyvsp[(2) - (5)].num)) != KT_FN) {
+					ERR(ctx, _("'%s' is not a function key symbol"),
+						get_sym(ctx, KTYP((yyvsp[(2) - (5)].num)), KVAL((yyvsp[(2) - (5)].num))));
+					YYERROR;
+				}
+
+				ke.kb_func = KVAL((yyvsp[(2) - (5)].num));
+				strncpy((char *) ke.kb_string,
+				        (char *) (yyvsp[(4) - (5)].str).data,
+				        sizeof(ke.kb_string));
+				ke.kb_string[sizeof(ke.kb_string) - 1] = 0;
+
+				if (lk_add_func(ctx, &ke) == -1)
+					YYERROR;
+			}
+    break;
+
+  case 24:
+/* Line 1787 of yacc.c  */
+#line 276 "parser.y"
+    {
+				struct lk_kbdiacr ptr;
+				ptr.diacr  = (yyvsp[(2) - (6)].num);
+				ptr.base   = (yyvsp[(3) - (6)].num);
+				ptr.result = (yyvsp[(5) - (6)].num);
+
+				if (lk_append_compose(ctx, &ptr) == -1)
+					YYERROR;
+			}
+    break;
+
+  case 25:
+/* Line 1787 of yacc.c  */
+#line 286 "parser.y"
+    {
+				struct lk_kbdiacr ptr;
+				ptr.diacr  = (yyvsp[(2) - (6)].num);
+				ptr.base   = (yyvsp[(3) - (6)].num);
+				ptr.result = (yyvsp[(5) - (6)].num);
+
+				if (lk_append_compose(ctx, &ptr) == -1)
+					YYERROR;
+			}
+    break;
+
+  case 26:
+/* Line 1787 of yacc.c  */
+#line 296 "parser.y"
+    {	(yyval.num) = (yyvsp[(1) - (1)].num);		}
+    break;
+
+  case 27:
+/* Line 1787 of yacc.c  */
+#line 297 "parser.y"
+    {	(yyval.num) = (yyvsp[(1) - (1)].num) ^ 0xf000;	}
+    break;
+
+  case 28:
+/* Line 1787 of yacc.c  */
+#line 300 "parser.y"
+    {
+				unsigned int j, i, keycode;
+				int *val;
+
+				if (ctx->key_line->count == 1) {
+					char one = 1;
+					/* Some files do not have a keymaps line, and
+					 * we have to wait until all input has been read
+					 * before we know which maps to fill. */
+					lk_array_set(ctx->key_constant, (yyvsp[(2) - (5)].num), &one);
+
+					/* On the other hand, we now have include files,
+					 * and it should be possible to override lines
+					 * from an include file. So, kill old defs. */
+					for (j = 0; j < ctx->keymap->total; j++) {
+						if (!lk_map_exists(ctx, j))
+							continue;
+
+						if (lk_del_key(ctx, j, (yyvsp[(2) - (5)].num)) < 0)
+							YYERROR;
+					}
+				}
+
+				if (ctx->keywords & LK_KEYWORD_KEYMAPS) {
+					i = 0;
+
+					for (j = 0; j < ctx->keymap->total; j++) {
+						if (!lk_map_exists(ctx, j))
+							continue;
+
+						if (ctx->key_line->count != 1 || i == 0) {
+							keycode = K_HOLE;
+
+							if (i < ctx->key_line->count) {
+								val = lk_array_get(ctx->key_line, i);
+								keycode = *val;
+							}
+
+							if (lk_add_key(ctx, j, (yyvsp[(2) - (5)].num), keycode) < 0)
+								YYERROR;
+						}
+						i++;
+					}
+
+					if (i < ctx->key_line->count) {
+						ERR(ctx, _("too many (%d) entries on one line"),
+							ctx->key_line->count);
+						YYERROR;
+					}
+				} else {
+					for (i = 0; i < ctx->key_line->count; i++) {
+						val = lk_array_get(ctx->key_line, i);
+
+						if (lk_add_key(ctx, i, (yyvsp[(2) - (5)].num), *val) < 0)
+							YYERROR;
+					}
+				}
+			}
+    break;
+
+  case 29:
+/* Line 1787 of yacc.c  */
+#line 360 "parser.y"
+    {
+				if (lk_add_key(ctx, ctx->mod, (yyvsp[(3) - (6)].num), (yyvsp[(5) - (6)].num)) < 0)
+					YYERROR;
+				ctx->mod = 0;
+			}
+    break;
+
+  case 30:
+/* Line 1787 of yacc.c  */
+#line 366 "parser.y"
+    {
+				if (lk_add_key(ctx, 0, (yyvsp[(3) - (6)].num), (yyvsp[(5) - (6)].num)) < 0)
+					YYERROR;
+				ctx->mod = 0;
+			}
+    break;
+
+  case 33:
+/* Line 1787 of yacc.c  */
+#line 375 "parser.y"
+    { ctx->mod |= M_SHIFT;	}
+    break;
+
+  case 34:
+/* Line 1787 of yacc.c  */
+#line 376 "parser.y"
+    { ctx->mod |= M_CTRL;	}
+    break;
+
+  case 35:
+/* Line 1787 of yacc.c  */
+#line 377 "parser.y"
+    { ctx->mod |= M_ALT;		}
+    break;
+
+  case 36:
+/* Line 1787 of yacc.c  */
+#line 378 "parser.y"
+    { ctx->mod |= M_ALTGR;	}
+    break;
+
+  case 37:
+/* Line 1787 of yacc.c  */
+#line 379 "parser.y"
+    { ctx->mod |= M_SHIFTL;	}
+    break;
+
+  case 38:
+/* Line 1787 of yacc.c  */
+#line 380 "parser.y"
+    { ctx->mod |= M_SHIFTR;	}
+    break;
+
+  case 39:
+/* Line 1787 of yacc.c  */
+#line 381 "parser.y"
+    { ctx->mod |= M_CTRLL;	}
+    break;
+
+  case 40:
+/* Line 1787 of yacc.c  */
+#line 382 "parser.y"
+    { ctx->mod |= M_CTRLR;	}
+    break;
+
+  case 41:
+/* Line 1787 of yacc.c  */
+#line 383 "parser.y"
+    { ctx->mod |= M_CAPSSHIFT;	}
+    break;
+
+  case 44:
+/* Line 1787 of yacc.c  */
+#line 391 "parser.y"
+    {
+				int val = (yyvsp[(1) - (1)].num);
+				lk_array_append(ctx->key_line, &val);
+			}
+    break;
+
+  case 45:
+/* Line 1787 of yacc.c  */
+#line 396 "parser.y"
+    { (yyval.num) = convert_code(ctx, (yyvsp[(1) - (1)].num), TO_AUTO);		}
+    break;
+
+  case 46:
+/* Line 1787 of yacc.c  */
+#line 397 "parser.y"
+    { (yyval.num) = add_capslock(ctx, (yyvsp[(2) - (2)].num));			}
+    break;
+
+  case 47:
+/* Line 1787 of yacc.c  */
+#line 398 "parser.y"
+    { (yyval.num) = convert_code(ctx, (yyvsp[(1) - (1)].num)^0xf000, TO_AUTO);	}
+    break;
+
+  case 48:
+/* Line 1787 of yacc.c  */
+#line 399 "parser.y"
+    { (yyval.num) = add_capslock(ctx, (yyvsp[(2) - (2)].num)^0xf000);		}
+    break;
+
+  case 49:
+/* Line 1787 of yacc.c  */
+#line 400 "parser.y"
+    { (yyval.num) = (yyvsp[(1) - (1)].num);					}
+    break;
+
+  case 50:
+/* Line 1787 of yacc.c  */
+#line 401 "parser.y"
+    { (yyval.num) = add_capslock(ctx, (yyvsp[(2) - (2)].num));			}
+    break;
+
+
+/* Line 1787 of yacc.c  */
+#line 1979 "parser.c"
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (scanner, ctx, YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (scanner, ctx, yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval, scanner, ctx);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp, scanner, ctx);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (scanner, ctx, YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval, scanner, ctx);
+    }
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp, scanner, ctx);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+/* Line 2050 of yacc.c  */
+#line 403 "parser.y"
+
+
+int
+lk_parse_keymap(struct lk_ctx *ctx, lkfile_t *f)
+{
+	yyscan_t scanner;
+	int rc = -1;
+
+	ctx->mod = 0;
+
+	yylex_init(&scanner);
+	yylex_init_extra(ctx, &scanner);
+
+	INFO(ctx, _("Loading %s"), f->pathname);
+
+	if (stack_push(ctx, f, scanner) == -1)
+		goto fail;
+
+	if (yyparse(scanner, ctx))
+		goto fail;
+
+	rc = 0;
+
+	stack_pop(ctx, scanner);
+
+ fail:	yylex_destroy(scanner);
+	return rc;
+}
diff --git a/src/libkeymap/parser.h b/src/libkeymap/parser.h
new file mode 100644
index 0000000..99251df
--- /dev/null
+++ b/src/libkeymap/parser.h
@@ -0,0 +1,172 @@
+/* A Bison parser, made by GNU Bison 2.7.1.  */
+
+/* Bison interface for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_PARSER_H_INCLUDED
+# define YY_YY_PARSER_H_INCLUDED
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+/* "%code requires" blocks.  */
+/* Line 2053 of yacc.c  */
+#line 26 "parser.y"
+
+#include "keymap.h"
+
+#ifndef STRDATA_STRUCT
+#define STRDATA_STRUCT
+#define MAX_PARSER_STRING 512
+struct strdata {
+	unsigned int len;
+	unsigned char data[MAX_PARSER_STRING];
+};
+#endif
+
+
+/* Line 2053 of yacc.c  */
+#line 60 "parser.h"
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     EOL = 258,
+     NUMBER = 259,
+     LITERAL = 260,
+     CHARSET = 261,
+     KEYMAPS = 262,
+     KEYCODE = 263,
+     EQUALS = 264,
+     PLAIN = 265,
+     SHIFT = 266,
+     CONTROL = 267,
+     ALT = 268,
+     ALTGR = 269,
+     SHIFTL = 270,
+     SHIFTR = 271,
+     CTRLL = 272,
+     CTRLR = 273,
+     CAPSSHIFT = 274,
+     COMMA = 275,
+     DASH = 276,
+     STRING = 277,
+     STRLITERAL = 278,
+     COMPOSE = 279,
+     TO = 280,
+     CCHAR = 281,
+     ERROR = 282,
+     PLUS = 283,
+     UNUMBER = 284,
+     ALT_IS_META = 285,
+     STRINGS = 286,
+     AS = 287,
+     USUAL = 288,
+     ON = 289,
+     FOR = 290
+   };
+#endif
+/* Tokens.  */
+#define EOL 258
+#define NUMBER 259
+#define LITERAL 260
+#define CHARSET 261
+#define KEYMAPS 262
+#define KEYCODE 263
+#define EQUALS 264
+#define PLAIN 265
+#define SHIFT 266
+#define CONTROL 267
+#define ALT 268
+#define ALTGR 269
+#define SHIFTL 270
+#define SHIFTR 271
+#define CTRLL 272
+#define CTRLR 273
+#define CAPSSHIFT 274
+#define COMMA 275
+#define DASH 276
+#define STRING 277
+#define STRLITERAL 278
+#define COMPOSE 279
+#define TO 280
+#define CCHAR 281
+#define ERROR 282
+#define PLUS 283
+#define UNUMBER 284
+#define ALT_IS_META 285
+#define STRINGS 286
+#define AS 287
+#define USUAL 288
+#define ON 289
+#define FOR 290
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+/* Line 2053 of yacc.c  */
+#line 58 "parser.y"
+
+	long long int num;
+	struct strdata str;
+
+
+/* Line 2053 of yacc.c  */
+#line 151 "parser.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *scanner, struct lk_ctx *ctx);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+#endif /* !YY_YY_PARSER_H_INCLUDED  */
-- 
2.6.2

